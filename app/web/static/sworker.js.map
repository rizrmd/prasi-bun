{"mappings":"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","sources":["../../node_modules/@parcel/service-worker/runtime-b447b4ae84ac8f48.js","../../node_modules/@parcel/service-worker/service-worker.js","src/sworker.ts","../../node_modules/radix3/dist/index.mjs"],"sourcesContent":["import {_register} from '@parcel/service-worker';\nconst manifest = [\"/index.js\",\"/pages.297d11c9.js\",\"/login.116f51a6.js\",\"/logout.4a23bd73.js\",\"/register.6da13020.js\",\"/all.2a032bf1.js\",\"/ed.de27588b.js\",\"/editor.b81cc496.js\",\"/editor.73d38fbd.js\",\"/standalone.f3e74186.js\",\"/typescript.dbf03dd2.js\",\"/estree.7a133e28.js\",\"/versions.752026f5.js\",\"/ipc.0049bc9e.js\",\"/worker.0b25d7de.js\",\"/dist.f8eecf79.js\",\"/Side.fa071797.js\",\"/index.module.15cb72f1.js\",\"/Side.d0586ad5.js\",\"/page-mgr.6c081154.js\",\"/site-mgr.aa4495d1.js\",\"/comp-mgr.27b10bdd.js\",\"/editor.9f6769c5.css\",\"/editor.ed238427.js\",\"/live.7c683dce.js\",\"/index.css\"];\nconst version = \"d5d7c01e\";\n_register(manifest, version);\n","export let manifest = [];\nexport let version = '';\n\n// Called by the runtime.\nexport function _register(m, v) {\n  manifest = m;\n  version = v;\n}\n","import { manifest, version } from \"@parcel/service-worker\";\nimport { RadixRouter, createRouter } from \"radix3\";\nconst g = {\n  router: null as null | RadixRouter<any>,\n  broadcast(msg: any) {\n    // @ts-ignore\n    const c: Clients = self.clients;\n    c.matchAll({ includeUncontrolled: true }).then((clients) => {\n      clients.forEach((client) => {\n        client.postMessage(msg);\n      });\n    });\n  },\n};\n\nasync function install() {\n  const cache = await caches.open(version);\n  await cache.addAll(manifest);\n  g.broadcast({ type: \"installed\" });\n}\naddEventListener(\"install\", (e) => (e as ExtendableEvent).waitUntil(install()));\n\nasync function activate() {\n  let shouldRefresh = false;\n  const keys = await caches.keys();\n  await Promise.all(\n    keys.map(async (key) => {\n      if (key !== version) {\n        await caches.delete(key);\n        shouldRefresh = true;\n      }\n    })\n  );\n\n  g.broadcast({ type: \"activated\", shouldRefresh });\n}\naddEventListener(\"activate\", (e) =>\n  (e as ExtendableEvent).waitUntil(activate())\n);\n\naddEventListener(\"fetch\", async (evt) => {\n  const e = evt as FetchEvent;\n\n  const url = new URL(e.request.url);\n\n  if (g.router) {\n    const found = g.router.lookup(url.pathname);\n    if (found) {\n      return;\n    }\n  }\n\n  e.respondWith(\n    (async () => {\n      const r = await caches.match(e.request);\n      if (r) {\n        return r;\n      }\n      return fetch(e.request);\n    })()\n  );\n});\ng.broadcast({ type: \"ready\" });\naddEventListener(\"message\", async (e) => {\n  const type = e.data.type;\n  const cache = await caches.open(version);\n\n  switch (type) {\n    case \"add-cache\":\n      if (!(await cache.match(e.data.url))) {\n        await cache.add(e.data.url);\n      }\n      break;\n    case \"define-route\":\n      console.log(\"defining route\", e.data.routes);\n      g.router = createRouter({ strictTrailingSlash: false });\n      for (const route of e.data.routes) {\n        g.router.insert(route.url, route);\n      }\n      await activate();\n      break;\n  }\n});\n","const NODE_TYPES = {\n  NORMAL: 0,\n  WILDCARD: 1,\n  PLACEHOLDER: 2\n};\n\nfunction createRouter(options = {}) {\n  const ctx = {\n    options,\n    rootNode: createRadixNode(),\n    staticRoutesMap: {}\n  };\n  const normalizeTrailingSlash = (p) => options.strictTrailingSlash ? p : p.replace(/\\/$/, \"\") || \"/\";\n  if (options.routes) {\n    for (const path in options.routes) {\n      insert(ctx, normalizeTrailingSlash(path), options.routes[path]);\n    }\n  }\n  return {\n    ctx,\n    // @ts-ignore\n    lookup: (path) => lookup(ctx, normalizeTrailingSlash(path)),\n    insert: (path, data) => insert(ctx, normalizeTrailingSlash(path), data),\n    remove: (path) => remove(ctx, normalizeTrailingSlash(path))\n  };\n}\nfunction lookup(ctx, path) {\n  const staticPathNode = ctx.staticRoutesMap[path];\n  if (staticPathNode) {\n    return staticPathNode.data;\n  }\n  const sections = path.split(\"/\");\n  const params = {};\n  let paramsFound = false;\n  let wildcardNode = null;\n  let node = ctx.rootNode;\n  let wildCardParam = null;\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i];\n    if (node.wildcardChildNode !== null) {\n      wildcardNode = node.wildcardChildNode;\n      wildCardParam = sections.slice(i).join(\"/\");\n    }\n    const nextNode = node.children.get(section);\n    if (nextNode !== void 0) {\n      node = nextNode;\n    } else {\n      node = node.placeholderChildNode;\n      if (node !== null) {\n        params[node.paramName] = section;\n        paramsFound = true;\n      } else {\n        break;\n      }\n    }\n  }\n  if ((node === null || node.data === null) && wildcardNode !== null) {\n    node = wildcardNode;\n    params[node.paramName || \"_\"] = wildCardParam;\n    paramsFound = true;\n  }\n  if (!node) {\n    return null;\n  }\n  if (paramsFound) {\n    return {\n      ...node.data,\n      params: paramsFound ? params : void 0\n    };\n  }\n  return node.data;\n}\nfunction insert(ctx, path, data) {\n  let isStaticRoute = true;\n  const sections = path.split(\"/\");\n  let node = ctx.rootNode;\n  let _unnamedPlaceholderCtr = 0;\n  for (const section of sections) {\n    let childNode;\n    if (childNode = node.children.get(section)) {\n      node = childNode;\n    } else {\n      const type = getNodeType(section);\n      childNode = createRadixNode({ type, parent: node });\n      node.children.set(section, childNode);\n      if (type === NODE_TYPES.PLACEHOLDER) {\n        childNode.paramName = section === \"*\" ? `_${_unnamedPlaceholderCtr++}` : section.slice(1);\n        node.placeholderChildNode = childNode;\n        isStaticRoute = false;\n      } else if (type === NODE_TYPES.WILDCARD) {\n        node.wildcardChildNode = childNode;\n        childNode.paramName = section.slice(\n          3\n          /* \"**:\" */\n        ) || \"_\";\n        isStaticRoute = false;\n      }\n      node = childNode;\n    }\n  }\n  node.data = data;\n  if (isStaticRoute === true) {\n    ctx.staticRoutesMap[path] = node;\n  }\n  return node;\n}\nfunction remove(ctx, path) {\n  let success = false;\n  const sections = path.split(\"/\");\n  let node = ctx.rootNode;\n  for (const section of sections) {\n    node = node.children.get(section);\n    if (!node) {\n      return success;\n    }\n  }\n  if (node.data) {\n    const lastSection = sections[sections.length - 1];\n    node.data = null;\n    if (Object.keys(node.children).length === 0) {\n      const parentNode = node.parent;\n      parentNode.children.delete(lastSection);\n      parentNode.wildcardChildNode = null;\n      parentNode.placeholderChildNode = null;\n    }\n    success = true;\n  }\n  return success;\n}\nfunction createRadixNode(options = {}) {\n  return {\n    type: options.type || NODE_TYPES.NORMAL,\n    parent: options.parent || null,\n    children: /* @__PURE__ */ new Map(),\n    data: options.data || null,\n    paramName: options.paramName || null,\n    wildcardChildNode: null,\n    placeholderChildNode: null\n  };\n}\nfunction getNodeType(str) {\n  if (str.startsWith(\"**\")) {\n    return NODE_TYPES.WILDCARD;\n  }\n  if (str[0] === \":\" || str === \"*\") {\n    return NODE_TYPES.PLACEHOLDER;\n  }\n  return NODE_TYPES.NORMAL;\n}\n\nfunction toRouteMatcher(router) {\n  const table = _routerNodeToTable(\"\", router.ctx.rootNode);\n  return _createMatcher(table);\n}\nfunction _createMatcher(table) {\n  return {\n    ctx: { table },\n    matchAll: (path) => _matchRoutes(path, table)\n  };\n}\nfunction _createRouteTable() {\n  return {\n    static: /* @__PURE__ */ new Map(),\n    wildcard: /* @__PURE__ */ new Map(),\n    dynamic: /* @__PURE__ */ new Map()\n  };\n}\nfunction _exportMatcherFromTable(table) {\n  const obj = /* @__PURE__ */ Object.create(null);\n  for (const property in table) {\n    obj[property] = property === \"dynamic\" ? Object.fromEntries(\n      [...table[property].entries()].map(([key, value]) => [\n        key,\n        _exportMatcherFromTable(value)\n      ])\n    ) : Object.fromEntries(table[property].entries());\n  }\n  return obj;\n}\nfunction exportMatcher(matcher) {\n  return _exportMatcherFromTable(matcher.ctx.table);\n}\nfunction _createTableFromExport(matcherExport) {\n  const table = {};\n  for (const property in matcherExport) {\n    table[property] = property === \"dynamic\" ? new Map(\n      Object.entries(matcherExport[property]).map(([key, value]) => [\n        key,\n        _createTableFromExport(value)\n      ])\n    ) : new Map(Object.entries(matcherExport[property]));\n  }\n  return table;\n}\nfunction createMatcherFromExport(matcherExport) {\n  return _createMatcher(_createTableFromExport(matcherExport));\n}\nfunction _matchRoutes(path, table) {\n  const matches = [];\n  for (const [key, value] of _sortRoutesMap(table.wildcard)) {\n    if (path.startsWith(key)) {\n      matches.push(value);\n    }\n  }\n  for (const [key, value] of _sortRoutesMap(table.dynamic)) {\n    if (path.startsWith(key + \"/\")) {\n      const subPath = \"/\" + path.slice(key.length).split(\"/\").splice(2).join(\"/\");\n      matches.push(..._matchRoutes(subPath, value));\n    }\n  }\n  const staticMatch = table.static.get(path);\n  if (staticMatch) {\n    matches.push(staticMatch);\n  }\n  return matches.filter(Boolean);\n}\nfunction _sortRoutesMap(m) {\n  return [...m.entries()].sort((a, b) => a[0].length - b[0].length);\n}\nfunction _routerNodeToTable(initialPath, initialNode) {\n  const table = _createRouteTable();\n  function _addNode(path, node) {\n    if (path) {\n      if (node.type === NODE_TYPES.NORMAL && !(path.includes(\"*\") || path.includes(\":\"))) {\n        table.static.set(path, node.data);\n      } else if (node.type === NODE_TYPES.WILDCARD) {\n        table.wildcard.set(path.replace(\"/**\", \"\"), node.data);\n      } else if (node.type === NODE_TYPES.PLACEHOLDER) {\n        const subTable = _routerNodeToTable(\"\", node);\n        if (node.data) {\n          subTable.static.set(\"/\", node.data);\n        }\n        table.dynamic.set(path.replace(/\\/\\*|\\/:\\w+/, \"\"), subTable);\n        return;\n      }\n    }\n    for (const [childPath, child] of node.children.entries()) {\n      _addNode(`${path}/${childPath}`.replace(\"//\", \"/\"), child);\n    }\n  }\n  _addNode(initialPath, initialNode);\n  return table;\n}\n\nexport { NODE_TYPES, createMatcherFromExport, createRouter, exportMatcher, toRouteMatcher };\n"],"names":[],"version":3,"file":"sworker.js.map"}