{"mappings":"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","sources":["../../node_modules/y-pojo/dist/y-pojo.js"],"sourcesContent":["import * as Y from \"yjs\";\nexport function deepEquals(managed, target) {\n    const managedType = detectManagedType(managed);\n    try {\n        var targetType = target.constructor.name;\n    }\n    catch (e) {\n        targetType = \"undefined\";\n    }\n    if (managedType == \"YArray\" && targetType == \"Array\") {\n        const targetArray = target;\n        const managedArray = managed;\n        const result = managedArray.length == targetArray.length && targetArray.every((t, i) => deepEquals(managedArray.get(i), targetArray[i]));\n        return result;\n    }\n    else if (managedType == \"YMap\" && targetType == \"Object\") {\n        const targetMap = target;\n        const managedMap = managed;\n        let targetKeyCount = 0;\n        for (let targetKey in targetMap) {\n            targetKeyCount++;\n            if (!deepEquals(managedMap.get(targetKey), targetMap[targetKey])) {\n                return false;\n            }\n        }\n        return targetKeyCount == Array.from(managedMap.keys()).length;\n    }\n    else {\n        return target === managed;\n    }\n}\nexport function syncronize(managedObj, targetObj) {\n    let changed = false;\n    const managedType = detectManagedType(managedObj);\n    switch (managedType) {\n        case \"YArray\":\n            if (!Array.isArray(targetObj)) {\n                throw new Error(`Sync failed, ${targetObj} was not array`);\n            }\n            const managedArray = managedObj;\n            const targetArray = targetObj;\n            const outOfRange = Symbol();\n            let cursor = 0;\n            for (let i = 0; i < targetArray.length; i++) {\n                let match = false;\n                const targetValue = targetArray[i];\n                const len = (managedArray.length > targetArray.length) ? managedArray.length : targetArray.length;\n                for (let j = cursor; !match && j < len; j++) {\n                    const managedValue = (j < managedArray.length) ? managedArray.get(j) : outOfRange;\n                    const targetValue = (i < targetArray.length) ? targetArray[i] : outOfRange;\n                    if (deepEquals(managedValue, targetValue)) {\n                        for (let x = j - 1; x >= cursor; x--) {\n                            changed = true;\n                            managedArray.delete(x);\n                        }\n                        const deletedCount = j - cursor;\n                        cursor = j + 1 - deletedCount;\n                        match = true;\n                    }\n                }\n                if (!match) {\n                    try {\n                        var childType = targetValue.constructor.name;\n                    }\n                    catch (e) {\n                        childType = \"undefined\";\n                    }\n                    const managedChild = (cursor < managedArray.length) ? managedArray.get(cursor) : \"undefined\";\n                    const managedType = detectManagedType(managedChild);\n                    // but if they're compatible types we should go deeper\n                    // there was no exact match in the list, so assume the immediately next object should be the match\n                    if ((managedType == \"YMap\" && childType == \"Object\") ||\n                        (managedType == \"YArray\" && childType == \"Array\")) {\n                        syncronize(managedChild, targetValue);\n                    }\n                    else {\n                        managedArray.insert(cursor, [syncChild(targetValue)]);\n                    }\n                    cursor++;\n                    changed = true;\n                }\n            }\n            while (managedArray.length > targetArray.length) {\n                changed = true;\n                managedArray.delete(targetArray.length);\n            }\n            break;\n        case \"YMap\":\n            if (targetObj.constructor.name !== \"Object\") {\n                throw new Error(`Sync failed, ${targetObj} was not object`);\n            }\n            const managedMap = managedObj;\n            const targetMap = targetObj;\n            for (const key of managedMap.keys()) {\n                if (!(key in targetObj)) {\n                    // item's been removed from target\n                    managedMap.delete(key);\n                    changed = true;\n                    continue;\n                }\n                const managedChild = managedMap.get(key);\n                const targetChild = targetMap[key];\n                const managedType = detectManagedType(managedChild);\n                try {\n                    var childType = targetChild.constructor.name;\n                }\n                catch (e) {\n                    childType = \"undefined\";\n                }\n                if ((managedType == \"YMap\" && childType !== \"Object\") ||\n                    (managedType == \"YArray\" && childType !== \"Array\") ||\n                    (![\"YMap\", \"YArray\"].includes(managedType) && managedType !== childType)) {\n                    // this item has fundamentally changed, delete the existing record and recreate it in second pass\n                    managedMap.delete(key);\n                    changed = true;\n                }\n                else if (managedType == \"YMap\" || managedType == \"YArray\") {\n                    // they match in types, so go deeper\n                    const childChanged = syncronize(managedChild, targetChild);\n                    changed || (changed = childChanged);\n                }\n                else {\n                    // they are not complex types so just assign it into the map\n                    if (managedChild !== targetChild) {\n                        managedMap.set(key, targetChild);\n                        changed = true;\n                    }\n                }\n            }\n            for (const key in targetMap) {\n                if (!managedMap.has(key)) {\n                    const child = syncChild(targetMap[key]);\n                    managedMap.set(key, child);\n                    changed = true;\n                }\n            }\n            break;\n        default:\n            throw new Error(`can only iterate over Y.Map and Y.Array, got ${managedObj}`);\n    }\n    return changed;\n}\nfunction syncChild(child) {\n    try {\n        var childType = child.constructor.name;\n    }\n    catch (e) {\n        childType = \"undefined\";\n    }\n    if (childType == \"Array\") {\n        const arr = new Y.Array();\n        syncronize(arr, child);\n        return arr;\n    }\n    else if (childType == \"Object\") {\n        const map = new Y.Map();\n        syncronize(map, child);\n        return map;\n    }\n    else {\n        return child;\n    }\n}\nfunction detectManagedType(managed) {\n    try {\n        if (managed.length !== undefined && managed.get !== undefined) {\n            return \"YArray\";\n        }\n        else if (managed.keys !== undefined && managed.get !== undefined) {\n            return \"YMap\";\n        }\n        else {\n            return managed.constructor.name;\n        }\n    }\n    catch (e) {\n        return \"undefined\";\n    }\n}\n"],"names":[],"version":3,"file":"y-pojo.d28b9ce4.js.map","sourceRoot":"../app/web/"}